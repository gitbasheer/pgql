// @ts-nocheck
import { nanoid } from 'nanoid';
import { promises as fs } from 'fs';
import * as path from 'path';
import { createTwoFilesPatch } from 'diff';
import diff2html from 'diff2html';
import { logger } from '../../utils/logger.js';
import {
  ValidationReport,
  ValidationSummary,
  ComparisonResult,
  AlignmentFunction,
  ABTestConfig,
  Difference,
} from './types.js';

export class ValidationReportGenerator {
  constructor(
    private options: {
      outputDir: string;
      formats: Array<'json' | 'html' | 'markdown' | 'csv' | 'junit'>;
      includeDiffs?: boolean;
    } = {
      outputDir: './validation-reports',
      formats: ['json', 'html', 'markdown'],
      includeDiffs: true,
    },
  ) {}

  async generateFullReport(
    comparisons: ComparisonResult[],
    alignments: AlignmentFunction[],
    abTestConfig?: ABTestConfig,
  ): Promise<ValidationReport> {
    const report: ValidationReport = {
      id: nanoid(),
      createdAt: new Date(),
      summary: this.calculateSummary(comparisons),
      comparisons,
      alignments,
      abTestConfig,
      recommendations: this.generateRecommendations(comparisons, alignments),
    };

    // Save report in all requested formats
    await this.saveReport(report);

    return report;
  }

  generatePRSummary(report: ValidationReport): string {
    const { summary } = report;
    const emoji = this.getStatusEmoji(summary.estimatedRisk);

    const lines = [
      `## ${emoji} GraphQL Migration Validation Report`,
      '',
      '### Summary',
      `- **Total Queries**: ${summary.totalQueries}`,
      `- **Identical Responses**: ${summary.identicalQueries} (${this.percentage(summary.identicalQueries, summary.totalQueries)}%)`,
      `- **Modified Responses**: ${summary.modifiedQueries} (${this.percentage(summary.modifiedQueries, summary.totalQueries)}%)`,
      `- **Breaking Changes**: ${summary.breakingChanges}`,
      `- **Average Similarity**: ${(summary.averageSimilarity * 100).toFixed(1)}%`,
      `- **Risk Level**: ${summary.estimatedRisk.toUpperCase()}`,
      `- **Safe to Migrate**: ${summary.safeToMigrate ? 'Yes ✅' : 'No ❌'}`,
      '',
    ];

    if (summary.breakingChanges > 0) {
      lines.push('### ⚠️ Breaking Changes Detected');
      lines.push('');

      const breakingChanges = report.comparisons.flatMap((c) => c.breakingChanges).slice(0, 5); // Show first 5

      for (const change of breakingChanges) {
        lines.push(`- **${change.type}** at \`${change.path.join('.')}\`: ${change.description}`);
      }

      if (report.comparisons.flatMap((c) => c.breakingChanges).length > 5) {
        lines.push(
          `- ... and ${report.comparisons.flatMap((c) => c.breakingChanges).length - 5} more`,
        );
      }
      lines.push('');
    }

    if (report.alignments.length > 0) {
      lines.push('### 🔧 Auto-Generated Alignments');
      lines.push('');
      lines.push(
        `${report.alignments.length} alignment functions were generated to handle response differences.`,
      );
      lines.push('');
    }

    if (report.recommendations.length > 0) {
      lines.push('### 📋 Recommendations');
      lines.push('');
      for (const rec of report.recommendations.slice(0, 3)) {
        lines.push(`- ${rec}`);
      }
      lines.push('');
    }

    if (report.abTestConfig) {
      lines.push('### 🧪 A/B Testing Configuration');
      lines.push('');
      lines.push(`- **Strategy**: ${report.abTestConfig.rolloutStrategy.type}`);
      lines.push(`- **Initial Split**: ${report.abTestConfig.splitPercentage}%`);
      lines.push(
        `- **Auto-Rollback**: ${report.abTestConfig.autoRollback.enabled ? 'Enabled' : 'Disabled'}`,
      );
      lines.push('');
    }

    lines.push('---');
    lines.push('*Generated by pg-migration-620 Response Validator*');

    return lines.join('\n');
  }

  generateCIReport(report: ValidationReport): {
    passed: boolean;
    message: string;
    details: Record<string, any>;
    exitCode: number;
    summary: {
      total: number;
      passed: number;
      failed: number;
      warnings: number;
    };
  } {
    const passed = report.summary.safeToMigrate && report.summary.breakingChanges === 0;
    const breakingChanges = report.comparisons.flatMap((c) => c.breakingChanges);

    const summary = {
      total: report.summary.totalQueries,
      passed: report.summary.identicalQueries,
      failed: report.summary.breakingChanges,
      warnings: report.summary.modifiedQueries - report.summary.breakingChanges,
    };

    const ciReport = {
      passed,
      message: passed
        ? 'GraphQL migration validation passed'
        : `GraphQL migration validation failed: ${report.summary.breakingChanges} breaking changes detected`,
      exitCode: passed ? 0 : 1,
      summary,
      details: {
        summary: report.summary,
        breakingChanges: breakingChanges.map((bc) => ({
          ...bc,
          suggestion: this.generateFixSuggestion(bc),
        })),
        recommendations: report.recommendations,
        ignoredDifferences: this.extractIgnoredDifferences(report),
      },
    };

    // Generate JUnit XML if requested
    if (this.options.formats.includes('junit' as any)) {
      this.generateJUnitReport(report, ciReport);
    }

    return ciReport;
  }

  private calculateSummary(comparisons: ComparisonResult[]): ValidationSummary {
    const totalQueries = comparisons.length;
    const identicalQueries = comparisons.filter((c) => c.identical).length;
    const modifiedQueries = totalQueries - identicalQueries;
    const breakingChanges = comparisons.reduce((sum, c) => sum + c.breakingChanges.length, 0);
    const averageSimilarity =
      comparisons.reduce((sum, c) => sum + c.similarity, 0) / totalQueries || 0;

    const safeToMigrate = breakingChanges === 0 && averageSimilarity > 0.95;
    const estimatedRisk = this.estimateRisk(breakingChanges, averageSimilarity);

    return {
      totalQueries,
      identicalQueries,
      modifiedQueries,
      breakingChanges,
      averageSimilarity,
      safeToMigrate,
      estimatedRisk,
    };
  }

  private estimateRisk(
    breakingChanges: number,
    averageSimilarity: number,
  ): 'low' | 'medium' | 'high' {
    if (breakingChanges > 0) return 'high';
    if (averageSimilarity < 0.9) return 'high';
    if (averageSimilarity < 0.95) return 'medium';
    return 'low';
  }

  private generateRecommendations(
    comparisons: ComparisonResult[],
    alignments: AlignmentFunction[],
  ): string[] {
    const recommendations: string[] = [];

    // Check for breaking changes
    const breakingChanges = comparisons.flatMap((c) => c.breakingChanges);
    if (breakingChanges.length > 0) {
      recommendations.push(
        `Address ${breakingChanges.length} breaking changes before migrating to production`,
      );
    }

    // Check similarity scores
    const lowSimilarityQueries = comparisons.filter((c) => c.similarity < 0.9);
    if (lowSimilarityQueries.length > 0) {
      recommendations.push(
        `Review ${lowSimilarityQueries.length} queries with low similarity scores (<90%)`,
      );
    }

    // Check performance impact
    const performanceIssues = comparisons.filter(
      (c) => Math.abs(c.performanceImpact.latencyChange) > 20,
    );
    if (performanceIssues.length > 0) {
      recommendations.push(
        `Monitor performance for ${performanceIssues.length} queries with significant latency changes`,
      );
    }

    // Alignment recommendations
    if (alignments.length > 0) {
      recommendations.push(
        `Test ${alignments.length} auto-generated alignment functions thoroughly before deployment`,
      );
    }

    // A/B testing recommendation
    if (breakingChanges.length === 0 && comparisons.length > 10) {
      recommendations.push('Consider gradual rollout with A/B testing for production safety');
    }

    // Review recommendation
    const needsReview = comparisons.filter((c) => c.recommendation === 'review');
    if (needsReview.length > 0) {
      recommendations.push(`Manual review recommended for ${needsReview.length} queries`);
    }

    return recommendations;
  }

  private async saveReport(report: ValidationReport): Promise<void> {
    await this.ensureDirectory(this.options.outputDir!);

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const baseFilename = `validation-report-${timestamp}`;

    for (const format of this.options.formats!) {
      switch (format) {
        case 'html':
          await this.saveHTMLReport(report, baseFilename);
          break;
        case 'markdown':
          await this.saveMarkdownReport(report, baseFilename);
          break;
        case 'json':
          await this.saveJSONReport(report, baseFilename);
          break;
        case 'csv':
          await this.saveCSVReport(report, baseFilename);
          break;
      }
    }
  }

  private async saveHTMLReport(report: ValidationReport, baseFilename: string): Promise<void> {
    const html = this.generateHTMLReport(report);
    const filepath = path.join(this.options.outputDir!, `${baseFilename}.html`);
    await fs.writeFile(filepath, html, 'utf-8');
    logger.info(`Saved HTML report to ${filepath}`);
  }

  private generateHTMLReport(report: ValidationReport): string {
    const { summary } = report;

    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL Migration Validation Report</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { color: #333; }
        h2 { color: #555; margin-top: 30px; }
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .metric {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
        }
        .metric-label {
            color: #666;
            margin-top: 5px;
        }
        .status-safe { color: #28a745; }
        .status-warning { color: #ffc107; }
        .status-danger { color: #dc3545; }
        .comparison {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .diff-container {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        pre {
            margin: 0;
            white-space: pre-wrap;
        }
        .recommendation {
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 10px 0;
        }
        .breaking-change {
            background: #ffe7e7;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>GraphQL Migration Validation Report</h1>
        <p>Generated on ${report.createdAt.toLocaleString()}</p>

        <h2>Summary</h2>
        <div class="summary">
            <div class="metric">
                <div class="metric-value">${summary.totalQueries}</div>
                <div class="metric-label">Total Queries</div>
            </div>
            <div class="metric">
                <div class="metric-value ${summary.averageSimilarity > 0.95 ? 'status-safe' : 'status-warning'}">
                    ${(summary.averageSimilarity * 100).toFixed(1)}%
                </div>
                <div class="metric-label">Average Similarity</div>
            </div>
            <div class="metric">
                <div class="metric-value ${summary.breakingChanges === 0 ? 'status-safe' : 'status-danger'}">
                    ${summary.breakingChanges}
                </div>
                <div class="metric-label">Breaking Changes</div>
            </div>
            <div class="metric">
                <div class="metric-value ${summary.safeToMigrate ? 'status-safe' : 'status-danger'}">
                    ${summary.safeToMigrate ? '✅ Yes' : '❌ No'}
                </div>
                <div class="metric-label">Safe to Migrate</div>
            </div>
        </div>

        ${this.generateHTMLBreakingChanges(report)}
        ${this.generateHTMLRecommendations(report)}
        ${this.generateHTMLComparisons(report)}
        ${this.generateHTMLAlignments(report)}
    </div>
</body>
</html>
    `.trim();
  }

  private generateHTMLBreakingChanges(report: ValidationReport): string {
    const breakingChanges = report.comparisons.flatMap((c) => c.breakingChanges);
    if (breakingChanges.length === 0) return '';

    const changes = breakingChanges
      .slice(0, 10)
      .map(
        (change) => `
        <div class="breaking-change">
            <strong>${change.type}</strong> at <code>${change.path.join('.')}</code><br>
            ${change.description}<br>
            <small>Impact: ${change.impact} | Strategy: ${change.migrationStrategy}</small>
        </div>
    `,
      )
      .join('');

    return `
        <h2>Breaking Changes</h2>
        ${changes}
        ${breakingChanges.length > 10 ? `<p>... and ${breakingChanges.length - 10} more</p>` : ''}
    `;
  }

  private generateHTMLRecommendations(report: ValidationReport): string {
    if (report.recommendations.length === 0) return '';

    const recs = report.recommendations
      .map(
        (rec) => `
        <div class="recommendation">${rec}</div>
    `,
      )
      .join('');

    return `
        <h2>Recommendations</h2>
        ${recs}
    `;
  }

  private generateHTMLComparisons(report: ValidationReport): string {
    // Show first few comparisons with issues
    const issueComparisons = report.comparisons.filter((c) => !c.identical).slice(0, 5);

    if (issueComparisons.length === 0) return '';

    const comparisons = issueComparisons
      .map(
        (comp) => `
        <div class="comparison">
            <h3>Query: ${comp.queryId}</h3>
            <p>
                Similarity: <strong>${(comp.similarity * 100).toFixed(1)}%</strong> |
                Recommendation: <strong class="${this.getRecommendationClass(comp.recommendation)}">
                    ${comp.recommendation.toUpperCase()}
                </strong>
            </p>
            ${
              comp.differences.length > 0
                ? `
                <h4>Differences (${comp.differences.length})</h4>
                <div class="diff-container">
                    <pre>${this.formatDifferences(comp.differences)}</pre>
                </div>
            `
                : ''
            }
        </div>
    `,
      )
      .join('');

    return `
        <h2>Query Comparisons</h2>
        ${comparisons}
    `;
  }

  private generateHTMLAlignments(report: ValidationReport): string {
    if (report.alignments.length === 0) return '';

    const alignments = report.alignments
      .slice(0, 3)
      .map(
        (alignment) => `
        <div class="comparison">
            <h3>Alignment for Query: ${alignment.queryId}</h3>
            <div class="diff-container">
                <pre><code>${alignment.code}</code></pre>
            </div>
        </div>
    `,
      )
      .join('');

    return `
        <h2>Generated Alignment Functions</h2>
        ${alignments}
        ${report.alignments.length > 3 ? `<p>... and ${report.alignments.length - 3} more</p>` : ''}
    `;
  }

  private async saveMarkdownReport(report: ValidationReport, baseFilename: string): Promise<void> {
    const markdown = this.generateMarkdownReport(report);
    const filepath = path.join(this.options.outputDir!, `${baseFilename}.md`);
    await fs.writeFile(filepath, markdown, 'utf-8');
    logger.info(`Saved Markdown report to ${filepath}`);
  }

  private generateMarkdownReport(report: ValidationReport): string {
    const lines = [
      '# GraphQL Migration Validation Report',
      '',
      `Generated on: ${report.createdAt.toISOString()}`,
      '',
      this.generatePRSummary(report),
      '',
      '## Detailed Results',
      '',
    ];

    // Add detailed comparisons
    const issueComparisons = report.comparisons.filter((c) => !c.identical);
    if (issueComparisons.length > 0) {
      lines.push('### Queries with Differences');
      lines.push('');

      for (const comp of issueComparisons.slice(0, 10)) {
        lines.push(`#### ${comp.queryId}`);
        lines.push(`- Similarity: ${(comp.similarity * 100).toFixed(1)}%`);
        lines.push(`- Differences: ${comp.differences.length}`);
        lines.push(`- Breaking Changes: ${comp.breakingChanges.length}`);
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  private async saveJSONReport(report: ValidationReport, baseFilename: string): Promise<void> {
    const filepath = path.join(this.options.outputDir!, `${baseFilename}.json`);
    const data = this.options.formats.includes('json')
      ? report
      : {
          id: report.id,
          createdAt: report.createdAt,
          summary: report.summary,
          recommendations: report.recommendations,
          breakingChanges: report.comparisons.flatMap((c) => c.breakingChanges),
        };
    await fs.writeFile(filepath, JSON.stringify(data, null, 2), 'utf-8');
    logger.info(`Saved JSON report to ${filepath}`);
  }

  private async saveCSVReport(report: ValidationReport, baseFilename: string): Promise<void> {
    const csv = this.generateCSVReport(report);
    const filepath = path.join(this.options.outputDir!, `${baseFilename}.csv`);
    await fs.writeFile(filepath, csv, 'utf-8');
    logger.info(`Saved CSV report to ${filepath}`);
  }

  private generateCSVReport(report: ValidationReport): string {
    const headers = [
      'Query ID',
      'Operation Name',
      'Identical',
      'Similarity',
      'Differences',
      'Breaking Changes',
      'Performance Impact',
      'Recommendation',
    ];

    const rows = report.comparisons.map((comp) => [
      comp.queryId,
      comp.operationName || '',
      comp.identical ? 'Yes' : 'No',
      (comp.similarity * 100).toFixed(1) + '%',
      comp.differences.length.toString(),
      comp.breakingChanges.length.toString(),
      comp.performanceImpact.latencyChange.toFixed(1) + '%',
      comp.recommendation,
    ]);

    return [headers.join(','), ...rows.map((row) => row.map((cell) => `"${cell}"`).join(','))].join(
      '\n',
    );
  }

  private formatDifferences(differences: Difference[]): string {
    return differences
      .slice(0, 5)
      .map(
        (diff) => `${diff.severity.toUpperCase()}: ${diff.description} at ${diff.path.join('.')}`,
      )
      .join('\n');
  }

  private getRecommendationClass(recommendation: string): string {
    switch (recommendation) {
      case 'safe':
        return 'status-safe';
      case 'review':
        return 'status-warning';
      case 'unsafe':
        return 'status-danger';
      default:
        return '';
    }
  }

  private getStatusEmoji(risk: string): string {
    switch (risk) {
      case 'low':
        return '✅';
      case 'medium':
        return '⚠️';
      case 'high':
        return '🚨';
      default:
        return '❓';
    }
  }

  private percentage(part: number, total: number): number {
    if (total === 0) return 0;
    return Math.round((part / total) * 100);
  }

  private async ensureDirectory(dirPath: string): Promise<void> {
    try {
      await fs.access(dirPath);
    } catch {
      await fs.mkdir(dirPath, { recursive: true });
    }
  }

  private generateFixSuggestion(breakingChange: any): string {
    switch (breakingChange.type) {
      case 'removed-field':
        return `Add a field mapping in your alignment function to handle the missing field '${breakingChange.path}'.`;
      case 'type-change':
        return `Add type conversion for '${breakingChange.path}' in your alignment function.`;
      case 'semantic-change':
        return `Review the structural change at '${breakingChange.path}' and update client code accordingly.`;
      default:
        return breakingChange.migrationStrategy || 'Review this change and update as needed.';
    }
  }

  private extractIgnoredDifferences(report: ValidationReport): Array<{
    path: string;
    reason: string;
    count: number;
  }> {
    const ignored: Record<string, { reason: string; count: number }> = {};

    for (const comparison of report.comparisons) {
      for (const diff of comparison.differences) {
        if (diff.ignored) {
          const key = `${diff.path}:${diff.ignored}`;
          if (!ignored[key]) {
            ignored[key] = { reason: diff.ignored, count: 0 };
          }
          ignored[key].count++;
        }
      }
    }

    return Object.entries(ignored).map(([pathAndReason, data]) => {
      const [path] = pathAndReason.split(':');
      return {
        path,
        reason: data.reason,
        count: data.count,
      };
    });
  }

  private async generateJUnitReport(report: ValidationReport, ciReport: any): Promise<void> {
    const junit = this.createJUnitXML(report, ciReport);
    const outputPath = path.join(this.options.outputDir, 'validation-junit.xml');

    await fs.mkdir(this.options.outputDir, { recursive: true });
    await fs.writeFile(outputPath, junit, 'utf-8');

    logger.info(`JUnit report saved to ${outputPath}`);
  }

  private createJUnitXML(report: ValidationReport, ciReport: any): string {
    const testCases = report.comparisons
      .map((comparison) => {
        const status = comparison.identical
          ? 'passed'
          : comparison.breakingChanges.length > 0
            ? 'failed'
            : 'warning';

        const testCase = `
    <testcase name="${comparison.queryId}" classname="GraphQLMigration.ResponseValidation" time="0">
      ${
        status === 'failed'
          ? `
      <failure message="${comparison.breakingChanges.length} breaking changes detected">
${comparison.breakingChanges.map((bc) => `- ${bc.type}: ${bc.description}`).join('\n')}
      </failure>`
          : ''
      }
      ${
        status === 'warning'
          ? `
      <system-out>
${comparison.differences.length} non-breaking differences detected
      </system-out>`
          : ''
      }
    </testcase>`;

        return testCase;
      })
      .join('\n');

    return `<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="GraphQL Migration Validation" tests="${report.summary.totalQueries}" failures="${ciReport.summary.failed}" warnings="${ciReport.summary.warnings}" time="0">
  <testsuite name="Response Validation" tests="${report.summary.totalQueries}" failures="${ciReport.summary.failed}" warnings="${ciReport.summary.warnings}" time="0">
${testCases}
  </testsuite>
</testsuites>`;
  }

  async generateFullReport(report: ValidationReport): Promise<string> {
    const timestamp = new Date().toISOString();
    const reportId = `validation-${timestamp.replace(/[:.]/g, '-')}`;
    const reportDir = path.join(this.options.outputDir, reportId);

    await fs.mkdir(reportDir, { recursive: true });

    // Generate each format
    for (const format of this.options.formats) {
      switch (format) {
        case 'json':
          await this.saveJSONReport(report, path.join(reportDir, 'report'));
          break;
        case 'html':
          await this.generateHTMLReport(report, path.join(reportDir, 'report'));
          break;
        case 'markdown':
          await this.generateMarkdownReport(report, path.join(reportDir, 'report'));
          break;
        case 'csv':
          await this.generateCSVReport(report, path.join(reportDir, 'report'));
          break;
      }
    }

    // Generate diffs if requested
    if (this.options.includeDiffs) {
      await this.generateDiffs(report, reportDir);
    }

    logger.info(`Full validation report generated in ${reportDir}`);
    return reportDir;
  }

  private async generateDiffs(report: ValidationReport, outputDir: string): Promise<void> {
    const diffsDir = path.join(outputDir, 'diffs');
    await fs.mkdir(diffsDir, { recursive: true });

    for (const comparison of report.comparisons) {
      if (!comparison.identical && comparison.differences.length > 0) {
        const diffContent = this.createDiffForComparison(comparison);
        const diffPath = path.join(diffsDir, `${comparison.queryId}.diff`);
        await fs.writeFile(diffPath, diffContent, 'utf-8');
      }
    }
  }

  private createDiffForComparison(comparison: ComparisonResult): string {
    const sections: string[] = [];

    // Add header
    sections.push(`Query: ${comparison.queryId}`);
    sections.push(`Operation: ${comparison.operationName || 'Unknown'}`);
    sections.push(`Similarity: ${(comparison.similarity * 100).toFixed(1)}%`);
    sections.push('---\n');

    // Add breaking changes
    if (comparison.breakingChanges.length > 0) {
      sections.push('BREAKING CHANGES:');
      comparison.breakingChanges.forEach((bc) => {
        sections.push(`  - ${bc.type}: ${bc.description}`);
        sections.push(`    Impact: ${bc.impact}`);
        sections.push(`    Suggestion: ${this.generateFixSuggestion(bc)}`);
      });
      sections.push('');
    }

    // Add differences with visual diffs
    sections.push('DIFFERENCES:');
    comparison.differences.forEach((diff) => {
      sections.push(`\nPath: ${diff.path}`);
      sections.push(`Type: ${diff.type}`);
      sections.push(`Severity: ${diff.severity}`);

      if (diff.ignored) {
        sections.push(`Status: IGNORED (${diff.ignored})`);
      }

      // Create visual diff
      const baselineStr = JSON.stringify(diff.baseline, null, 2);
      const transformedStr = JSON.stringify(diff.transformed, null, 2);

      const patch = createTwoFilesPatch(
        'baseline',
        'transformed',
        baselineStr,
        transformedStr,
        'Baseline Response',
        'Transformed Response',
      );

      sections.push(patch);
    });

    return sections.join('\n');
  }
}
