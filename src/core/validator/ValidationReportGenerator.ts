import { nanoid } from 'nanoid';
import { promises as fs } from 'fs';
import path from 'path';
import diff2html from 'diff2html';
import { logger } from '../../utils/logger';
import {
  ValidationReport,
  ValidationSummary,
  ComparisonResult,
  AlignmentFunction,
  ABTestConfig,
  Difference
} from './types';

export class ValidationReportGenerator {
  constructor(
    private options: {
      outputDir?: string;
      includeTimestamps?: boolean;
      includeRawData?: boolean;
      formats?: Array<'html' | 'markdown' | 'json' | 'csv'>;
    } = {}
  ) {
    this.options.outputDir = this.options.outputDir || './validation-reports';
    this.options.formats = this.options.formats || ['html', 'markdown'];
    this.options.includeTimestamps = this.options.includeTimestamps ?? true;
    this.options.includeRawData = this.options.includeRawData ?? false;
  }

  async generateFullReport(
    comparisons: ComparisonResult[],
    alignments: AlignmentFunction[],
    abTestConfig?: ABTestConfig
  ): Promise<ValidationReport> {
    const report: ValidationReport = {
      id: nanoid(),
      createdAt: new Date(),
      summary: this.calculateSummary(comparisons),
      comparisons,
      alignments,
      abTestConfig,
      recommendations: this.generateRecommendations(comparisons, alignments)
    };

    // Save report in all requested formats
    await this.saveReport(report);

    return report;
  }

  generatePRSummary(report: ValidationReport): string {
    const { summary } = report;
    const emoji = this.getStatusEmoji(summary.estimatedRisk);

    const lines = [
      `## ${emoji} GraphQL Migration Validation Report`,
      '',
      '### Summary',
      `- **Total Queries**: ${summary.totalQueries}`,
      `- **Identical Responses**: ${summary.identicalQueries} (${this.percentage(summary.identicalQueries, summary.totalQueries)}%)`,
      `- **Modified Responses**: ${summary.modifiedQueries} (${this.percentage(summary.modifiedQueries, summary.totalQueries)}%)`,
      `- **Breaking Changes**: ${summary.breakingChanges}`,
      `- **Average Similarity**: ${(summary.averageSimilarity * 100).toFixed(1)}%`,
      `- **Risk Level**: ${summary.estimatedRisk.toUpperCase()}`,
      `- **Safe to Migrate**: ${summary.safeToMigrate ? 'Yes ✅' : 'No ❌'}`,
      ''
    ];

    if (summary.breakingChanges > 0) {
      lines.push('### ⚠️ Breaking Changes Detected');
      lines.push('');
      
      const breakingChanges = report.comparisons
        .flatMap(c => c.breakingChanges)
        .slice(0, 5); // Show first 5

      for (const change of breakingChanges) {
        lines.push(`- **${change.type}** at \`${change.path.join('.')}\`: ${change.description}`);
      }

      if (report.comparisons.flatMap(c => c.breakingChanges).length > 5) {
        lines.push(`- ... and ${report.comparisons.flatMap(c => c.breakingChanges).length - 5} more`);
      }
      lines.push('');
    }

    if (report.alignments.length > 0) {
      lines.push('### 🔧 Auto-Generated Alignments');
      lines.push('');
      lines.push(`${report.alignments.length} alignment functions were generated to handle response differences.`);
      lines.push('');
    }

    if (report.recommendations.length > 0) {
      lines.push('### 📋 Recommendations');
      lines.push('');
      for (const rec of report.recommendations.slice(0, 3)) {
        lines.push(`- ${rec}`);
      }
      lines.push('');
    }

    if (report.abTestConfig) {
      lines.push('### 🧪 A/B Testing Configuration');
      lines.push('');
      lines.push(`- **Strategy**: ${report.abTestConfig.rolloutStrategy.type}`);
      lines.push(`- **Initial Split**: ${report.abTestConfig.splitPercentage}%`);
      lines.push(`- **Auto-Rollback**: ${report.abTestConfig.autoRollback.enabled ? 'Enabled' : 'Disabled'}`);
      lines.push('');
    }

    lines.push('---');
    lines.push('*Generated by pg-migration-620 Response Validator*');

    return lines.join('\n');
  }

  generateCIReport(report: ValidationReport): {
    passed: boolean;
    message: string;
    details: Record<string, any>;
  } {
    const passed = report.summary.safeToMigrate && report.summary.breakingChanges === 0;

    return {
      passed,
      message: passed 
        ? 'GraphQL migration validation passed'
        : `GraphQL migration validation failed: ${report.summary.breakingChanges} breaking changes detected`,
      details: {
        summary: report.summary,
        breakingChanges: report.comparisons.flatMap(c => c.breakingChanges),
        recommendations: report.recommendations
      }
    };
  }

  private calculateSummary(comparisons: ComparisonResult[]): ValidationSummary {
    const totalQueries = comparisons.length;
    const identicalQueries = comparisons.filter(c => c.identical).length;
    const modifiedQueries = totalQueries - identicalQueries;
    const breakingChanges = comparisons.reduce((sum, c) => sum + c.breakingChanges.length, 0);
    const averageSimilarity = comparisons.reduce((sum, c) => sum + c.similarity, 0) / totalQueries || 0;

    const safeToMigrate = breakingChanges === 0 && averageSimilarity > 0.95;
    const estimatedRisk = this.estimateRisk(breakingChanges, averageSimilarity);

    return {
      totalQueries,
      identicalQueries,
      modifiedQueries,
      breakingChanges,
      averageSimilarity,
      safeToMigrate,
      estimatedRisk
    };
  }

  private estimateRisk(
    breakingChanges: number,
    averageSimilarity: number
  ): 'low' | 'medium' | 'high' {
    if (breakingChanges > 0) return 'high';
    if (averageSimilarity < 0.9) return 'high';
    if (averageSimilarity < 0.95) return 'medium';
    return 'low';
  }

  private generateRecommendations(
    comparisons: ComparisonResult[],
    alignments: AlignmentFunction[]
  ): string[] {
    const recommendations: string[] = [];

    // Check for breaking changes
    const breakingChanges = comparisons.flatMap(c => c.breakingChanges);
    if (breakingChanges.length > 0) {
      recommendations.push(
        `Address ${breakingChanges.length} breaking changes before migrating to production`
      );
    }

    // Check similarity scores
    const lowSimilarityQueries = comparisons.filter(c => c.similarity < 0.9);
    if (lowSimilarityQueries.length > 0) {
      recommendations.push(
        `Review ${lowSimilarityQueries.length} queries with low similarity scores (<90%)`
      );
    }

    // Check performance impact
    const performanceIssues = comparisons.filter(
      c => Math.abs(c.performanceImpact.latencyChange) > 20
    );
    if (performanceIssues.length > 0) {
      recommendations.push(
        `Monitor performance for ${performanceIssues.length} queries with significant latency changes`
      );
    }

    // Alignment recommendations
    if (alignments.length > 0) {
      recommendations.push(
        `Test ${alignments.length} auto-generated alignment functions thoroughly before deployment`
      );
    }

    // A/B testing recommendation
    if (breakingChanges.length === 0 && comparisons.length > 10) {
      recommendations.push(
        'Consider gradual rollout with A/B testing for production safety'
      );
    }

    // Review recommendation
    const needsReview = comparisons.filter(c => c.recommendation === 'review');
    if (needsReview.length > 0) {
      recommendations.push(
        `Manual review recommended for ${needsReview.length} queries`
      );
    }

    return recommendations;
  }

  private async saveReport(report: ValidationReport): Promise<void> {
    await this.ensureDirectory(this.options.outputDir!);

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const baseFilename = `validation-report-${timestamp}`;

    for (const format of this.options.formats!) {
      switch (format) {
        case 'html':
          await this.saveHTMLReport(report, baseFilename);
          break;
        case 'markdown':
          await this.saveMarkdownReport(report, baseFilename);
          break;
        case 'json':
          await this.saveJSONReport(report, baseFilename);
          break;
        case 'csv':
          await this.saveCSVReport(report, baseFilename);
          break;
      }
    }
  }

  private async saveHTMLReport(report: ValidationReport, baseFilename: string): Promise<void> {
    const html = this.generateHTMLReport(report);
    const filepath = path.join(this.options.outputDir!, `${baseFilename}.html`);
    await fs.writeFile(filepath, html, 'utf-8');
    logger.info(`Saved HTML report to ${filepath}`);
  }

  private generateHTMLReport(report: ValidationReport): string {
    const { summary } = report;

    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL Migration Validation Report</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { color: #333; }
        h2 { color: #555; margin-top: 30px; }
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .metric {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
        }
        .metric-label {
            color: #666;
            margin-top: 5px;
        }
        .status-safe { color: #28a745; }
        .status-warning { color: #ffc107; }
        .status-danger { color: #dc3545; }
        .comparison {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .diff-container {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        pre {
            margin: 0;
            white-space: pre-wrap;
        }
        .recommendation {
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 10px 0;
        }
        .breaking-change {
            background: #ffe7e7;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>GraphQL Migration Validation Report</h1>
        <p>Generated on ${report.createdAt.toLocaleString()}</p>
        
        <h2>Summary</h2>
        <div class="summary">
            <div class="metric">
                <div class="metric-value">${summary.totalQueries}</div>
                <div class="metric-label">Total Queries</div>
            </div>
            <div class="metric">
                <div class="metric-value ${summary.averageSimilarity > 0.95 ? 'status-safe' : 'status-warning'}">
                    ${(summary.averageSimilarity * 100).toFixed(1)}%
                </div>
                <div class="metric-label">Average Similarity</div>
            </div>
            <div class="metric">
                <div class="metric-value ${summary.breakingChanges === 0 ? 'status-safe' : 'status-danger'}">
                    ${summary.breakingChanges}
                </div>
                <div class="metric-label">Breaking Changes</div>
            </div>
            <div class="metric">
                <div class="metric-value ${summary.safeToMigrate ? 'status-safe' : 'status-danger'}">
                    ${summary.safeToMigrate ? '✅ Yes' : '❌ No'}
                </div>
                <div class="metric-label">Safe to Migrate</div>
            </div>
        </div>

        ${this.generateHTMLBreakingChanges(report)}
        ${this.generateHTMLRecommendations(report)}
        ${this.generateHTMLComparisons(report)}
        ${this.generateHTMLAlignments(report)}
    </div>
</body>
</html>
    `.trim();
  }

  private generateHTMLBreakingChanges(report: ValidationReport): string {
    const breakingChanges = report.comparisons.flatMap(c => c.breakingChanges);
    if (breakingChanges.length === 0) return '';

    const changes = breakingChanges.slice(0, 10).map(change => `
        <div class="breaking-change">
            <strong>${change.type}</strong> at <code>${change.path.join('.')}</code><br>
            ${change.description}<br>
            <small>Impact: ${change.impact} | Strategy: ${change.migrationStrategy}</small>
        </div>
    `).join('');

    return `
        <h2>Breaking Changes</h2>
        ${changes}
        ${breakingChanges.length > 10 ? `<p>... and ${breakingChanges.length - 10} more</p>` : ''}
    `;
  }

  private generateHTMLRecommendations(report: ValidationReport): string {
    if (report.recommendations.length === 0) return '';

    const recs = report.recommendations.map(rec => `
        <div class="recommendation">${rec}</div>
    `).join('');

    return `
        <h2>Recommendations</h2>
        ${recs}
    `;
  }

  private generateHTMLComparisons(report: ValidationReport): string {
    // Show first few comparisons with issues
    const issueComparisons = report.comparisons
      .filter(c => !c.identical)
      .slice(0, 5);

    if (issueComparisons.length === 0) return '';

    const comparisons = issueComparisons.map(comp => `
        <div class="comparison">
            <h3>Query: ${comp.queryId}</h3>
            <p>
                Similarity: <strong>${(comp.similarity * 100).toFixed(1)}%</strong> |
                Recommendation: <strong class="${this.getRecommendationClass(comp.recommendation)}">
                    ${comp.recommendation.toUpperCase()}
                </strong>
            </p>
            ${comp.differences.length > 0 ? `
                <h4>Differences (${comp.differences.length})</h4>
                <div class="diff-container">
                    <pre>${this.formatDifferences(comp.differences)}</pre>
                </div>
            ` : ''}
        </div>
    `).join('');

    return `
        <h2>Query Comparisons</h2>
        ${comparisons}
    `;
  }

  private generateHTMLAlignments(report: ValidationReport): string {
    if (report.alignments.length === 0) return '';

    const alignments = report.alignments.slice(0, 3).map(alignment => `
        <div class="comparison">
            <h3>Alignment for Query: ${alignment.queryId}</h3>
            <div class="diff-container">
                <pre><code>${alignment.code}</code></pre>
            </div>
        </div>
    `).join('');

    return `
        <h2>Generated Alignment Functions</h2>
        ${alignments}
        ${report.alignments.length > 3 ? `<p>... and ${report.alignments.length - 3} more</p>` : ''}
    `;
  }

  private async saveMarkdownReport(report: ValidationReport, baseFilename: string): Promise<void> {
    const markdown = this.generateMarkdownReport(report);
    const filepath = path.join(this.options.outputDir!, `${baseFilename}.md`);
    await fs.writeFile(filepath, markdown, 'utf-8');
    logger.info(`Saved Markdown report to ${filepath}`);
  }

  private generateMarkdownReport(report: ValidationReport): string {
    const lines = [
      '# GraphQL Migration Validation Report',
      '',
      `Generated on: ${report.createdAt.toISOString()}`,
      '',
      this.generatePRSummary(report),
      '',
      '## Detailed Results',
      ''
    ];

    // Add detailed comparisons
    const issueComparisons = report.comparisons.filter(c => !c.identical);
    if (issueComparisons.length > 0) {
      lines.push('### Queries with Differences');
      lines.push('');
      
      for (const comp of issueComparisons.slice(0, 10)) {
        lines.push(`#### ${comp.queryId}`);
        lines.push(`- Similarity: ${(comp.similarity * 100).toFixed(1)}%`);
        lines.push(`- Differences: ${comp.differences.length}`);
        lines.push(`- Breaking Changes: ${comp.breakingChanges.length}`);
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  private async saveJSONReport(report: ValidationReport, baseFilename: string): Promise<void> {
    const filepath = path.join(this.options.outputDir!, `${baseFilename}.json`);
    const data = this.options.includeRawData ? report : {
      id: report.id,
      createdAt: report.createdAt,
      summary: report.summary,
      recommendations: report.recommendations,
      breakingChanges: report.comparisons.flatMap(c => c.breakingChanges)
    };
    await fs.writeFile(filepath, JSON.stringify(data, null, 2), 'utf-8');
    logger.info(`Saved JSON report to ${filepath}`);
  }

  private async saveCSVReport(report: ValidationReport, baseFilename: string): Promise<void> {
    const csv = this.generateCSVReport(report);
    const filepath = path.join(this.options.outputDir!, `${baseFilename}.csv`);
    await fs.writeFile(filepath, csv, 'utf-8');
    logger.info(`Saved CSV report to ${filepath}`);
  }

  private generateCSVReport(report: ValidationReport): string {
    const headers = [
      'Query ID',
      'Operation Name',
      'Identical',
      'Similarity',
      'Differences',
      'Breaking Changes',
      'Performance Impact',
      'Recommendation'
    ];

    const rows = report.comparisons.map(comp => [
      comp.queryId,
      comp.operationName || '',
      comp.identical ? 'Yes' : 'No',
      (comp.similarity * 100).toFixed(1) + '%',
      comp.differences.length.toString(),
      comp.breakingChanges.length.toString(),
      comp.performanceImpact.latencyChange.toFixed(1) + '%',
      comp.recommendation
    ]);

    return [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');
  }

  private formatDifferences(differences: Difference[]): string {
    return differences.slice(0, 5).map(diff => 
      `${diff.severity.toUpperCase()}: ${diff.description} at ${diff.path.join('.')}`
    ).join('\n');
  }

  private getRecommendationClass(recommendation: string): string {
    switch (recommendation) {
      case 'safe': return 'status-safe';
      case 'review': return 'status-warning';
      case 'unsafe': return 'status-danger';
      default: return '';
    }
  }

  private getStatusEmoji(risk: string): string {
    switch (risk) {
      case 'low': return '✅';
      case 'medium': return '⚠️';
      case 'high': return '🚨';
      default: return '❓';
    }
  }

  private percentage(part: number, total: number): number {
    if (total === 0) return 0;
    return Math.round((part / total) * 100);
  }

  private async ensureDirectory(dirPath: string): Promise<void> {
    try {
      await fs.access(dirPath);
    } catch {
      await fs.mkdir(dirPath, { recursive: true });
    }
  }
} 